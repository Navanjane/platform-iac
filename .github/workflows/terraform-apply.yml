name: Terraform Apply

on:
  push:
    branches:
      - develop
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main
      - develop
  workflow_dispatch:  # Manual trigger

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.14.3
  TF_VAR_use_iam_role: false  # GitHub Actions already assumed the role
  TF_VAR_domain_name: ${{ vars.DOMAIN_NAME }}  # Set in repository variables

jobs:
  terraform-plan:
    name: Terraform Validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event.action != 'closed' || (github.event.action == 'closed' && github.event.pull_request.merged == true)
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Comment PR with Plan
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style ðŸ–Œ\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization âš™ï¸\`${{ steps.init.outcome }}\`
            #### Terraform Validation ðŸ¤–\`${{ steps.validate.outcome }}\`

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-init:
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
    name: Initialize Terraform
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: terraform-plan
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

  apply-iam:
    name: Apply IAM Module
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: terraform-init
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Apply IAM Module
        run: |
          echo "ðŸ“¦ Applying IAM module..."
          terraform apply -target=module.iam -auto-approve -input=false || echo "âš ï¸ IAM resources may already exist, continuing..."
        continue-on-error: true

  apply-vpc:
    name: Apply VPC Module
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: apply-iam
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Apply VPC Module
        run: |
          echo "ðŸ“¦ Applying VPC module..."
          terraform apply -target=module.vpc -auto-approve -input=false

  apply-eks:
    name: Apply EKS Module
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: apply-vpc
    permissions:
      contents: read
    outputs:
      cluster_name: ${{ steps.extract-cluster-name.outputs.cluster_name }}
      cluster_endpoint: ${{ steps.extract-cluster-name.outputs.cluster_endpoint }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Required to capture raw output

      - name: Terraform Init
        run: terraform init

      - name: Apply EKS Cluster
        run: |
          echo "ðŸ“¦ Applying EKS cluster..."
          terraform apply -target=module.eks.module.eks.aws_eks_cluster.this -auto-approve -input=false

      - name: Apply EKS Supporting Resources
        run: |
          echo "ðŸ“¦ Applying EKS supporting resources (security groups, IAM, KMS)..."
          terraform apply -target=module.eks.module.eks -auto-approve -input=false

      - name: Apply All Remaining Resources
        run: |
          echo "ðŸ“¦ Applying all remaining resources (node groups, addons)..."
          terraform apply -auto-approve -input=false
        continue-on-error: true

      - name: Extract Cluster Name and Details
        id: extract-cluster-name
        run: |
          echo "ðŸ“ Extracting EKS cluster information from Terraform state..."

          # Extract cluster name directly from state (same approach as provision.sh)
          CLUSTER_NAME=$(terraform state show 'module.eks.module.eks.aws_eks_cluster.this[0]' 2>/dev/null | grep -oP 'name\s+=\s+"\K[^"]+' || echo "platform-eks-dev")

          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "âœ… Cluster Name: ${CLUSTER_NAME}"

          # Also extract endpoint for verification
          CLUSTER_ENDPOINT=$(terraform state show 'module.eks.module.eks.aws_eks_cluster.this[0]' 2>/dev/null | grep -oP 'endpoint\s+=\s+"\K[^"]+' || echo "")
          echo "cluster_endpoint=${CLUSTER_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "âœ… Cluster Endpoint: ${CLUSTER_ENDPOINT}"

          # Cache cluster name to file (for backup)
          echo "${CLUSTER_NAME}" > .cluster_name

      - name: Upload Cluster Info as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: cluster-info
          path: .cluster_name
          retention-days: 7

      - name: Verify Deployment
        if: success()
        run: |
          echo "âœ… EKS deployment completed successfully"
          echo ""
          echo "ðŸ“Š EKS Cluster Information:"
          echo "  Cluster Name: ${{ steps.extract-cluster-name.outputs.cluster_name }}"
          echo "  Cluster Endpoint: ${{ steps.extract-cluster-name.outputs.cluster_endpoint }}"

  generate-kubeconfig:
    name: Generate Kubeconfig
    runs-on: ubuntu-latest
    needs: apply-eks
    timeout-minutes: 10
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Generate Kubeconfig
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ“ Generating kubeconfig for EKS cluster: ${CLUSTER_NAME}..."
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${CLUSTER_NAME} \
            --kubeconfig ./kubeconfig-${CLUSTER_NAME}
          echo "âœ… Kubeconfig generated successfully"

      - name: Verify Kubeconfig
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ” Verifying kubeconfig..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          kubectl version --client
          kubectl cluster-info

      - name: Upload Kubeconfig as Artifact
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig-${{ needs.apply-eks.outputs.cluster_name }}
          path: ./kubeconfig-${{ needs.apply-eks.outputs.cluster_name }}
          retention-days: 7

      - name: Kubeconfig Summary
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "âœ… Kubeconfig generation completed"
          echo ""
          echo "ðŸ“Š Cluster Information:"
          echo "  Name: ${CLUSTER_NAME}"
          echo "  Endpoint: ${{ needs.apply-eks.outputs.cluster_endpoint }}"
          echo ""
          echo "ðŸ“¥ Download Instructions:"
          echo "  1. Go to Actions tab -> This workflow run"
          echo "  2. Scroll to Artifacts section"
          echo "  3. Download 'kubeconfig-${CLUSTER_NAME}'"
          echo "  4. Use: export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}"


  verify-cluster:
    name: Verify Kubernetes Cluster
    runs-on: ubuntu-latest
    needs: [apply-eks, generate-kubeconfig]
    timeout-minutes: 10
    permissions:
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Download Kubeconfig Artifact
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.apply-eks.outputs.cluster_name }}
          path: .

      - name: Verify AWS CLI and Credentials
        run: |
          echo "ðŸ” Verifying AWS CLI and credentials..."
          aws --version
          aws sts get-caller-identity
          echo "âœ… AWS credentials verified"

      - name: Configure kubectl
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ”§ Configuring kubectl for cluster: ${CLUSTER_NAME}..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          kubectl version --client
          echo "âœ… kubectl configured successfully"

      - name: Verify Cluster Connection
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ” Verifying cluster connection..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: List All Pods
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ“¦ Listing all pods in all namespaces..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          kubectl get pods --all-namespaces -o wide

      - name: List System Components
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ”§ Checking system components..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          echo ""
          echo "=== Namespaces ==="
          kubectl get namespaces
          echo ""
          echo "=== Deployments in kube-system ==="
          kubectl get deployments -n kube-system
          echo ""
          echo "=== DaemonSets in kube-system ==="
          kubectl get daemonsets -n kube-system

      - name: Cluster Health Summary
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "âœ… Kubernetes cluster verification completed"
          echo ""
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          echo "ðŸ“Š Cluster Summary:"
          echo "  Cluster: ${CLUSTER_NAME}"
          echo "  Nodes: $(kubectl get nodes --no-headers | wc -l)"
          echo "  Pods: $(kubectl get pods --all-namespaces --no-headers | wc -l)"
          echo "  Namespaces: $(kubectl get namespaces --no-headers | wc -l)"

  deploy-acm:
    name: Deploy ACM Certificate
    runs-on: ubuntu-latest
    needs: apply-eks
    timeout-minutes: 10
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Deploy ACM Module
        run: |
          echo "ðŸ“¦ Deploying ACM certificate (manual DNS validation required)..."
          terraform apply -target=module.acm -auto-approve -input=false
          echo "âœ… ACM certificate created (status: PENDING_VALIDATION)"

      - name: Output DNS Validation Records
        run: |
          echo "ðŸ“‹ DNS VALIDATION RECORDS - ADD THESE TO VERCEL DNS:"
          echo "================================================================"
          terraform output -json acm_dns_validation_records | jq -r '.[] | "Type: \(.type)\nName: \(.name)\nValue: \(.value)\n"'
          echo "================================================================"
          echo ""
          echo "âš ï¸ IMPORTANT: Add the DNS validation record(s) above to Vercel DNS"
          echo "   Domain: plat.navanjane.com"
          echo "   The certificate status will remain PENDING_VALIDATION until you do this"
          echo "   It may take a few minutes after adding the record for AWS to validate"

  deploy-alb-controller:
    name: Deploy AWS Load Balancer Controller
    runs-on: ubuntu-latest
    needs: [apply-eks, generate-kubeconfig]
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Download Kubeconfig Artifact
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.apply-eks.outputs.cluster_name }}
          path: .

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Deploy AWS Load Balancer Controller
        run: |
          echo "ðŸ“¦ Deploying AWS Load Balancer Controller..."
          terraform apply -target=module.aws_load_balancer_controller -auto-approve -input=false
          echo "âœ… AWS Load Balancer Controller deployed"

      - name: Verify Controller Deployment
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ” Verifying AWS Load Balancer Controller..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          kubectl wait --for=condition=Ready pods -l app.kubernetes.io/name=aws-load-balancer-controller -n kube-system --timeout=300s || echo "âš ï¸ Controller pods not ready yet"
          kubectl get deployment aws-load-balancer-controller -n kube-system

  deploy-argocd:
    name: Deploy ArgoCD with Ingress
    runs-on: ubuntu-latest
    needs: [deploy-alb-controller, deploy-acm]
    timeout-minutes: 30
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Deploy ArgoCD Module
        run: |
          echo "ðŸ“¦ Deploying ArgoCD with Ingress and ALB..."
          terraform apply -target=module.argocd -auto-approve -input=false
          echo "âœ… ArgoCD deployment with Ingress completed"

      - name: Display Access Information
        if: success()
        run: |
          echo "âœ… ArgoCD Access Information"
          echo "================================"
          echo ""
          echo "ðŸ”— ALB Hostname:"
          ALB_HOSTNAME=$(terraform output -raw argocd_alb_hostname || echo "ALB not ready yet")
          echo "$ALB_HOSTNAME"
          echo ""
          echo "ðŸ“‹ NEXT STEP - CREATE CNAME IN VERCEL DNS:"
          echo "================================================================"
          echo "Type: CNAME"
          echo "Name: plat (or @ for root domain)"
          echo "Value: $ALB_HOSTNAME"
          echo "TTL: 300 (or default)"
          echo "================================================================"
          echo ""
          echo "ðŸŒ After adding CNAME, access ArgoCD at:"
          terraform output -raw argocd_url || echo "https://plat.navanjane.com/argocd"
          echo ""
          echo ""
          echo "ðŸ“Š Certificate Status:"
          echo "  $(terraform output -raw acm_certificate_status)"
          echo "  âš ï¸ If PENDING_VALIDATION, add DNS validation records from deploy-acm job"
          echo ""
          echo "ðŸ“ Note: ArgoCD is accessible at path /argocd on the platform domain"

  verify-argocd-pods:
    name: Verify ArgoCD Pods
    runs-on: ubuntu-latest
    needs: [apply-eks, deploy-argocd]
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Download Kubeconfig Artifact
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-${{ needs.apply-eks.outputs.cluster_name }}
          path: .

      - name: Wait for ArgoCD Namespace
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "â³ Waiting for ArgoCD namespace to be created..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}

          timeout=300
          elapsed=0
          interval=5

          while ! kubectl get namespace argocd >/dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Timeout waiting for ArgoCD namespace"
              exit 1
            fi
            echo "Waiting for namespace... ($elapsed/$timeout seconds)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done

          echo "âœ… ArgoCD namespace found"

      - name: Wait for ArgoCD Pods
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "â³ Waiting for ArgoCD pods to be ready..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}

          echo "Waiting for ArgoCD pods to be created..."
          kubectl wait --for=condition=Ready pods --all -n argocd --timeout=600s || true

          echo ""
          echo "Current ArgoCD pod status:"
          kubectl get pods -n argocd

      - name: Verify ArgoCD Components
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ” Verifying ArgoCD components..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}

          echo ""
          echo "=== ArgoCD Pods ==="
          kubectl get pods -n argocd -o wide

          echo ""
          echo "=== ArgoCD Services ==="
          kubectl get svc -n argocd

          echo ""
          echo "=== ArgoCD Deployments ==="
          kubectl get deployments -n argocd

          echo ""
          echo "=== ArgoCD StatefulSets ==="
          kubectl get statefulsets -n argocd

      - name: Check ArgoCD Server Status
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ” Checking ArgoCD Server status..."
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}

          # Check if argocd-server deployment exists and is ready
          kubectl rollout status deployment/argocd-server -n argocd --timeout=300s || echo "âš ï¸ ArgoCD server not fully ready yet"

      - name: Get ArgoCD Access Information
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "ðŸ“‹ ArgoCD Access Information"
          echo "================================"
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}

          # Get LoadBalancer information
          echo ""
          echo "ArgoCD Server Service:"
          kubectl get svc argocd-server -n argocd

          # Get LoadBalancer URL if available
          LB_HOSTNAME=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          if [ "$LB_HOSTNAME" != "pending" ] && [ -n "$LB_HOSTNAME" ]; then
            echo ""
            echo "ðŸŒ ArgoCD Server URL: http://$LB_HOSTNAME"
          else
            echo ""
            echo "â³ LoadBalancer is provisioning. Check back in a few minutes."
          fi

          # Get initial admin password
          echo ""
          echo "ðŸ”‘ Initial Admin Password:"
          kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d || echo "Secret not found yet"
          echo ""

      - name: Verification Summary
        env:
          CLUSTER_NAME: ${{ needs.apply-eks.outputs.cluster_name }}
        run: |
          echo "âœ… ArgoCD verification completed"
          echo ""
          export KUBECONFIG=./kubeconfig-${CLUSTER_NAME}
          echo "ðŸ“Š ArgoCD Summary:"
          echo "  Cluster: ${CLUSTER_NAME}"
          echo "  Namespace: argocd"
          echo "  Pods: $(kubectl get pods -n argocd --no-headers 2>/dev/null | wc -l)"
          echo "  Ready Pods: $(kubectl get pods -n argocd --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)"
          echo ""
          echo "Next steps:"
          echo "  1. Wait for LoadBalancer to be provisioned"
          echo "  2. Access ArgoCD UI using the URL above"
          echo "  3. Login with username: admin"
          echo "  4. Use the initial admin password displayed above"
