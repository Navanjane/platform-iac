name: Terraform Apply

on:
  push:
    branches:
      - develop
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main
      - develop
  workflow_dispatch:  # Manual trigger

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.14.3
  TF_VAR_use_iam_role: false  # GitHub Actions already assumed the role

jobs:
  terraform-plan:
    name: Terraform Validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event.action != 'closed' || (github.event.action == 'closed' && github.event.pull_request.merged == true)
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Comment PR with Plan
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style ðŸ–Œ\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization âš™ï¸\`${{ steps.init.outcome }}\`
            #### Terraform Validation ðŸ¤–\`${{ steps.validate.outcome }}\`

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-init:
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
    name: Initialize Terraform
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: terraform-plan
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

  apply-iam:
    name: Apply IAM Module
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: terraform-init
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Apply IAM Module
        run: |
          echo "ðŸ“¦ Applying IAM module..."
          terraform apply -target=module.iam -auto-approve -input=false || echo "âš ï¸ IAM resources may already exist, continuing..."
        continue-on-error: true

  apply-vpc:
    name: Apply VPC Module
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: apply-iam
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Apply VPC Module
        run: |
          echo "ðŸ“¦ Applying VPC module..."
          terraform apply -target=module.vpc -auto-approve -input=false

  apply-eks:
    name: Apply EKS Module
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: apply-vpc
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 7200
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Apply EKS Cluster
        run: |
          echo "ðŸ“¦ Applying EKS cluster..."
          terraform apply -target=module.eks.module.eks.aws_eks_cluster.this -auto-approve -input=false

      - name: Apply EKS Supporting Resources
        run: |
          echo "ðŸ“¦ Applying EKS supporting resources (security groups, IAM, KMS)..."
          terraform apply -target=module.eks.module.eks -auto-approve -input=false

      - name: Apply All Remaining Resources
        run: |
          echo "ðŸ“¦ Applying all remaining resources (node groups, addons)..."
          terraform apply -auto-approve -input=false
        continue-on-error: true

      - name: Verify Deployment
        if: success()
        run: |
          echo "âœ… EKS deployment completed successfully"
          echo ""
          echo "ðŸ“Š Deployment Summary:"
          terraform output -json | jq -r 'to_entries[] | "  \(.key): \(.value.value)"'

  generate-kubeconfig:
    name: Generate Kubeconfig
    runs-on: ubuntu-latest
    needs: apply-eks
    timeout-minutes: 10
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Generate Kubeconfig
        run: |
          echo "ðŸ“ Generating kubeconfig for EKS cluster..."
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name platform-eks-dev \
            --kubeconfig ./kubeconfig-platform-eks-dev
          echo "âœ… Kubeconfig generated successfully"
          
      - name: Verify Kubeconfig
        run: |
          echo "ðŸ” Verifying kubeconfig..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          kubectl version --client
          kubectl cluster-info
          
      - name: Upload Kubeconfig as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig-platform-eks-dev
          path: ./kubeconfig-platform-eks-dev
          retention-days: 7
          
      - name: Kubeconfig Summary
        run: |
          echo "âœ… Kubeconfig generation completed"
          echo ""
          echo "ðŸ“¥ Download Instructions:"
          echo "  1. Go to Actions tab -> This workflow run"
          echo "  2. Scroll to Artifacts section"
          echo "  3. Download 'kubeconfig-platform-eks-dev'"
          echo "  4. Use: export KUBECONFIG=./kubeconfig-platform-eks-dev"


  verify-cluster:
    name: Verify Kubernetes Cluster
    runs-on: ubuntu-latest
    needs: generate-kubeconfig
    timeout-minutes: 10
    permissions:
      contents: read
    
    steps:
      - name: Download Kubeconfig Artifact
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-platform-eks-dev
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true
          
      - name: Configure kubectl
        run: |
          echo "ðŸ”§ Configuring kubectl..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          kubectl version --client
          echo "âœ… kubectl configured successfully"
          
      - name: Verify Cluster Connection
        run: |
          echo "ðŸ” Verifying cluster connection..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          kubectl cluster-info
          kubectl get nodes -o wide
          
      - name: List All Pods
        run: |
          echo "ðŸ“¦ Listing all pods in all namespaces..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          kubectl get pods --all-namespaces -o wide
          
      - name: List System Components
        run: |
          echo "ðŸ”§ Checking system components..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          echo ""
          echo "=== Namespaces ==="
          kubectl get namespaces
          echo ""
          echo "=== Deployments in kube-system ==="
          kubectl get deployments -n kube-system
          echo ""
          echo "=== DaemonSets in kube-system ==="
          kubectl get daemonsets -n kube-system
          
      - name: Cluster Health Summary
        run: |
          echo "âœ… Kubernetes cluster verification completed"
          echo ""
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          echo "ðŸ“Š Cluster Summary:"
          echo "  Nodes: $(kubectl get nodes --no-headers | wc -l)"
          echo "  Pods: $(kubectl get pods --all-namespaces --no-headers | wc -l)"
          echo "  Namespaces: $(kubectl get namespaces --no-headers | wc -l)"

  deploy-argocd:
    name: Deploy ArgoCD
    runs-on: ubuntu-latest
    needs: generate-kubeconfig
    timeout-minutes: 30
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Kubeconfig Artifact
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-platform-eks-dev
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: terraform init

      - name: Deploy ArgoCD Module
        run: |
          echo "ðŸ“¦ Deploying ArgoCD module..."
          terraform apply -target=module.argocd -auto-approve -input=false
          echo "âœ… ArgoCD deployment initiated"

      - name: Deployment Summary
        if: success()
        run: |
          echo "âœ… ArgoCD deployment completed successfully"
          echo ""
          echo "ðŸ“Š Deployment Summary:"
          terraform output -json | jq -r 'to_entries[] | select(.key | startswith("argocd")) | "  \(.key): \(.value.value)"'

  verify-argocd-pods:
    name: Verify ArgoCD Pods
    runs-on: ubuntu-latest
    needs: deploy-argocd
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Download Kubeconfig Artifact
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig-platform-eks-dev
          path: .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Wait for ArgoCD Namespace
        run: |
          echo "â³ Waiting for ArgoCD namespace to be created..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev

          timeout=300
          elapsed=0
          interval=5

          while ! kubectl get namespace argocd >/dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Timeout waiting for ArgoCD namespace"
              exit 1
            fi
            echo "Waiting for namespace... ($elapsed/$timeout seconds)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done

          echo "âœ… ArgoCD namespace found"

      - name: Wait for ArgoCD Pods
        run: |
          echo "â³ Waiting for ArgoCD pods to be ready..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev

          echo "Waiting for ArgoCD pods to be created..."
          kubectl wait --for=condition=Ready pods --all -n argocd --timeout=600s || true

          echo ""
          echo "Current ArgoCD pod status:"
          kubectl get pods -n argocd

      - name: Verify ArgoCD Components
        run: |
          echo "ðŸ” Verifying ArgoCD components..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev

          echo ""
          echo "=== ArgoCD Pods ==="
          kubectl get pods -n argocd -o wide

          echo ""
          echo "=== ArgoCD Services ==="
          kubectl get svc -n argocd

          echo ""
          echo "=== ArgoCD Deployments ==="
          kubectl get deployments -n argocd

          echo ""
          echo "=== ArgoCD StatefulSets ==="
          kubectl get statefulsets -n argocd

      - name: Check ArgoCD Server Status
        run: |
          echo "ðŸ” Checking ArgoCD Server status..."
          export KUBECONFIG=./kubeconfig-platform-eks-dev

          # Check if argocd-server deployment exists and is ready
          kubectl rollout status deployment/argocd-server -n argocd --timeout=300s || echo "âš ï¸ ArgoCD server not fully ready yet"

      - name: Get ArgoCD Access Information
        run: |
          echo "ðŸ“‹ ArgoCD Access Information"
          echo "================================"
          export KUBECONFIG=./kubeconfig-platform-eks-dev

          # Get LoadBalancer information
          echo ""
          echo "ArgoCD Server Service:"
          kubectl get svc argocd-server -n argocd

          # Get LoadBalancer URL if available
          LB_HOSTNAME=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          if [ "$LB_HOSTNAME" != "pending" ] && [ -n "$LB_HOSTNAME" ]; then
            echo ""
            echo "ðŸŒ ArgoCD Server URL: http://$LB_HOSTNAME"
          else
            echo ""
            echo "â³ LoadBalancer is provisioning. Check back in a few minutes."
          fi

          # Get initial admin password
          echo ""
          echo "ðŸ”‘ Initial Admin Password:"
          kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d || echo "Secret not found yet"
          echo ""

      - name: Verification Summary
        run: |
          echo "âœ… ArgoCD verification completed"
          echo ""
          export KUBECONFIG=./kubeconfig-platform-eks-dev
          echo "ðŸ“Š ArgoCD Summary:"
          echo "  Namespace: argocd"
          echo "  Pods: $(kubectl get pods -n argocd --no-headers 2>/dev/null | wc -l)"
          echo "  Ready Pods: $(kubectl get pods -n argocd --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l)"
          echo ""
          echo "Next steps:"
          echo "  1. Wait for LoadBalancer to be provisioned"
          echo "  2. Access ArgoCD UI using the URL above"
          echo "  3. Login with username: admin"
          echo "  4. Use the initial admin password displayed above"
